try { window } catch { console.error("This should be executed in the main browser environment."); process.exit(1); }
// Codename "Imagination"
// Note: generated by AI, might include some bad things
async function generateKeyPair() {
	const keyPair = await crypto.subtle.generateKey({
			name: 'RSA-OAEP',
			modulusLength: 2048,
			publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
			hash: 'SHA-256',
		},
		true,
		['encrypt', 'decrypt']
	);
	return keyPair;
}

async function exportKeyPair(keyPair) {
	const publicKeyDer = await crypto.subtle.exportKey('spki', keyPair.publicKey);
	const publicKeyPem = `-----BEGIN PUBLIC KEY-----\n${arrayBufferToBase64(publicKeyDer)}\n-----END PUBLIC KEY-----\n`;

	const privateKeyDer = await crypto.subtle.exportKey('pkcs8', keyPair.privateKey);
	const privateKeyPem = `-----BEGIN PRIVATE KEY-----\n${arrayBufferToBase64(privateKeyDer)}\n-----END PRIVATE KEY-----\n`;

	return {
		publicKeyPem,
		privateKeyPem
	};
}

async function importKeyPair(publicKeyPem, privateKeyPem) {
	const publicKeyDer = base64ToArrayBuffer(publicKeyPem.split('\n').slice(1, -2).join(''));
	const publicKey = await crypto.subtle.importKey('spki', publicKeyDer, {
		name: 'RSA-OAEP',
		hash: 'SHA-256'
	}, true, ['encrypt']);

	const privateKeyDer = base64ToArrayBuffer(privateKeyPem.split('\n').slice(1, -2).join(''));
	const privateKey = await crypto.subtle.importKey('pkcs8', privateKeyDer, {
		name: 'RSA-OAEP',
		hash: 'SHA-256'
	}, true, ['decrypt']);

	return {
		publicKey,
		privateKey
	};
}

async function decryptRSA(ciphertext, privateKey) {
	const decrypted = await crypto.subtle.decrypt({
		name: 'RSA-OAEP'
	}, privateKey, base64ToArrayBuffer(ciphertext));
	const plaintext = new TextDecoder().decode(decrypted);
	return plaintext;
}

async function encryptRSA(text, publicKey) {
	const encrypted = await crypto.subtle.encrypt({
		name: 'RSA-OAEP'
	}, publicKey, text);
	return arrayBufferToBase64(encrypted);
}

function arrayBufferToBase64(buffer) {
	let binary = '';
	const bytes = new Uint8Array(buffer);
	const len = bytes.byteLength;
	for (let i = 0; i < len; i++) {
		binary += String.fromCharCode(bytes[i]);
	}
	return btoa(binary);
}

function base64ToArrayBuffer(base64) {
	const binary = atob(base64);
	const len = binary.length;
	const bytes = new Uint8Array(len);
	for (let i = 0; i < len; i++) {
		bytes[i] = binary.charCodeAt(i);
	}
	return bytes.buffer;
}

async function encryptAES(data, password) {
	const encoder = new TextEncoder();
	const dataBuffer = encoder.encode(data);

	const salt = crypto.getRandomValues(new Uint8Array(16));

	const keyMaterial = await crypto.subtle.importKey(
		"raw",
		encoder.encode(password), {
			name: "PBKDF2"
		},
		false,
		["deriveKey"]
	);
	const aesKey = await crypto.subtle.deriveKey({
			name: "PBKDF2",
			salt: salt,
			iterations: 100000,
			hash: "SHA-256",
		},
		keyMaterial, {
			name: "AES-CBC",
			length: 256
		},
		true,
		["encrypt"]
	);

	const iv = crypto.getRandomValues(new Uint8Array(16));

	const encryptedData = await crypto.subtle.encrypt({
			name: "AES-CBC",
			iv: iv,
		},
		aesKey,
		dataBuffer
	);

	return {
		ciphertext: arrayBufferToBase64(encryptedData),
		salt: arrayBufferToBase64(salt),
		iv: arrayBufferToBase64(iv),
	};
}

async function decryptAES(data, password) {
	const decoder = new TextDecoder();

	const keyMaterial = await crypto.subtle.importKey(
		"raw",
		new TextEncoder().encode(password), {
			name: "PBKDF2"
		},
		false,
		["deriveKey"]
	);
	const aesKey = await crypto.subtle.deriveKey({
			name: "PBKDF2",
			salt: base64ToArrayBuffer(data.salt),
			iterations: 100000,
			hash: "SHA-256",
		},
		keyMaterial, {
			name: "AES-CBC",
			length: 256
		},
		true,
		["decrypt"]
	);

	const decryptedData = await crypto.subtle.decrypt({
			name: "AES-CBC",
			iv: base64ToArrayBuffer(data.iv),
		},
		aesKey,
		base64ToArrayBuffer(data.ciphertext)
	);

	return decoder.decode(decryptedData);
}